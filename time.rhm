#lang rhombus/and_meta

import "rrbtree.rhm" open
import "rbtree.rhm"
import rhombus/measure
import lib("racket/base.rkt") as rkt:
  expose: #{time-apply}
  rename: #{time-apply} as rkt_time
import lib("racket/vector.rkt") as vec

/* TODO compare against
      - racket vectors
      - hash tables mapping indices to values
      - cons lists

   we care about small trees, time doing X operation multiple times (100 times)? not just once

  make sure to time:
      - constructors
      - 

  goals: 10s or 100s of milliseconds
*/
class TimeBenchmark(~cpu, ~real, ~gc)

fun time(f, args) :~ TimeBenchmark:
  let (_, cpu, real, gc) = rkt_time(f, args)
  TimeBenchmark(~cpu: cpu, ~real: real, ~gc: gc)

macro 'times($f, $objs)':
  'for Map:
     each obj: $objs
     values(sizeof(obj), time($f, [obj]))'

macro 'bench ($name = $obj):
         ~times: $iterations
         $exp':
  'time(fun ($name):
          for (i: 0 .. $iterations):
            $exp,
        [$obj])'

class Timings(~list,
              ~rrb,
              ~rb,
              ~hash,
              ~rkt_vec,
              ~control,
              ~op,
              ~size,
              ~iters)

macro 'bench_for $op times $iters with name $name and size $sz:
         $_list: $_list_exp
         $_rrb: $_rrb_exp
         $_rb: $_rb_exp
         $_hash: $_hash_exp
         $_rkt_vec: $_rkt_vec_exp':
  'block:
     let (lst, rrb, rb, hsh, rkt_vec, control):
       values(
         bench ($name = $_list):
           ~times: $iters
           $_list_exp,
         bench ($name = $_rrb):
           ~times: $iters
           $_rrb_exp,
         bench ($name = $_rb):
           ~times: $iters
           $_rb_exp,
         bench ($name = $_hash):
           ~times: $iters
           $_hash_exp,
         bench ($name = $_rkt_vec):
           ~times: $iters
           $_rkt_vec_exp,
         bench ($name = #false):
           ~times: $iters
           #void)
     Timings(~list: lst,
             ~rrb: rrb,
             ~rb: rb,
             ~hash: hsh,
             ~rkt_vec: rkt_vec,
             ~op: $op,
             ~iters: $iters,
             ~size: $sz,
             ~control: control)'
def sizes = [1, 5, 10, 50, 100, 300, 500, 1000, 10000]
def iters = 1000
def ctor_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "ctor" times iters with name t and size sz:
             #void: List.iota(sz)
             #void: Tree().add_all(List.iota(sz))
             #void: rbtree.Vector.from(0..sz)
             #void: MutableMap(& for List:
                                 each i: 0 .. sz
                                 [i, i])
             #void: rkt.#{list->vector}(List.iota(sz)))

def snoc_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "add" times iters with name t and size sz:
             (List.iota(sz)): t.append(["foo"])
             (Tree().add_all(List.iota(sz))): t.add("foo")
             (rbtree.Vector.from(0..sz)): t.add("foo")
             (MutableMap(& for List:
                           each i: 0..sz
                           [i, i])): t[sz] := "foo"
             (rkt.#{list->vector}(List.iota(sz))): vec.#{vector-append}(t, rkt.vector("foo"))
           )

def cons_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "cons" times iters with name t and size sz:
             (List.iota(sz)): List.cons("foo", t)
             (Tree().add_all(List.iota(sz))): t.insert(0, "foo")
             (rbtree.Vector.from(0..sz)): for values(v = rbtree.Vector().add("foo")):
                                            each i: 0..sz
                                            v.add(t.get(i))
             (MutableMap(& for List:
                           each i: 0..sz
                           [i, i])): block:
                                       for (i: 1..sz+1):
                                         t[i] := t[i - 1]
                                       t[0] := "foo"
                                       t
             (rkt.#{list->vector}(List.iota(sz))): vec.#{vector-append}(rkt.vector("foo"), t)
           )

def concat_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "++" times iters with name t and size sz:
             (List.iota(sz)): t ++ t
             (Tree().add_all(List.iota(sz))): t ++ t
             (rbtree.Vector.from(0..sz)): for values(v = t):
                                            each i: 0..sz
                                            v.add(t.get(i))
             // Note that MutableMap is not Appendable while Map is.
             // seems like MutableMap should append just fine. In either case
             // ++ doesn't work here because t = Map(...) ++ t == t
             (MutableMap(& for List:
                           each i: 0..sz
                           [i, i])): block:
                                       for:
                                         each:
                                           i: sz..sz*2
                                           j: 0..sz
                                         t[i] := j
                                       t
             (rkt.#{list->vector}(List.iota(sz))): t ++ t
           )