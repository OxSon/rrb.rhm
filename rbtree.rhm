#lang rhombus/static
 
import "utils.rhm" open

export:
  Vec
  EMPTY_VEC

/* persistent vector a 'la Clojure */

def BITS = 5
def MAX_WIDTH = 32
def MASK = 31

macro 'radix($index, $level)':
  '((($index) bits.(>>) ($level)) bits.and MASK)'

module test:
  for (i: 0 .. 32):
    check: radix(i, 0)
           ~is i
    check: radix(i, 5)
           ~is 0
  for (i: 32 .. 64):
    check: radix(i, 5)
           ~is 1

class Node(data :: PVec):
  constructor
  | (): super(unsafe.freeze_vec(Array.make(MAX_WIDTH, #false)))
  | (data :: Array):
      def _data = Array.make(MAX_WIDTH, #false)
      Array.copy_from(_data, 0, data)
      super(unsafe.freeze_vec(_data))


module test:
  check: Node().data.length()
         ~is MAX_WIDTH
  check: Node(Array(1, 2, 3, 4)).data.length()
         ~is MAX_WIDTH


/* TODO 
  - optimization: transients
  - optimization: have a 'head' in addition to 'tail' kept separately? would allow constant prepend and append
*/
class Vector(root :: Node, size :: NonnegInt, shift :: NonnegInt, tail :: PVec):
  implements Indexable
  private implements Equatable
  private implements Appendable
  implements Sequenceable
  
  export from


  // NOTE: I want to go look at the source of List.iota.
  // this should be easy to do from the docs                     
  internal _V
  expression
  | 'Vector[]': '_V(Node(), 0, 0, pvec()) :~ Vector'
  | 'Vector[$(a :: Term)]': '_V(Node(), 1, 0, pvec($a)) :~ Vector'
  | 'Vector[$a, $b]': '_V(Node(), 2, 0, pvec($a, $b)) :~ Vector'
  | 'Vector[$a, $b, $c]': '_V(Node(), 3, 0, pvec($a, $b, $c)) :~ Vector'
  | 'Vector[$a, $b, $c, $d, ...]': 'Vec[$a, $b, $c].add_all(List($d, ...)) :~ Vector'
  | 'Vector()': '_V(Node(), 0, 0, pvec()) :~ Vector'
  | 'Vector(~from: $lst)': '_V(Node(), 0, 0, pvec()).add_all($lst) :~ Vector'
  | 'Vector($root, $size, $height, $tail)': '_V($root, $size, $height, $tail) :~ Vector'


  // doesn't work as described in docs?
  #//
  sequence '$lhs: $rhs':
    '(~outer_binds:
        p = $rhs,
      ~recur_binds:
        pos = 0,
      ~head_guard:
        pos < 2,
      ~inner_binds:
        $lhs = if pos == 0 | Posn.y(p) | Posn.x(p),
      ~recur_args:
        (pos + 1))'
    static_info:
      '(($statinfo_meta.index_result_key,
         $(annot_meta.parse_to_packed_statinfo('Int'))))'

  
  override method to_sequence():      
    Sequence.make(~initial_position: [0, array_for(0)],
                  ~continue_at_position: fun (pos): def [i, _] = pos
                                                    i < size,                 
                  ~position_to_next: fun (pos):
                                       def [i, arr] = pos
                                       def nexti = i + 1
                                       if nexti mod 32 == 0
                                       | [nexti, array_for(nexti)]
                                       | [nexti, arr],                    
                  ~position_to_element: fun (pos):                                            
                                          def [i :~ Number, arr :~ PVec] = pos
                                          arr.get(radix(i, 0))) // TODO why do i have to use .get here?

  
  private override equals(rhs :~ Vector, recur):
    size == rhs.size
      && recur(tail, rhs.tail)
      && recur(root, rhs.root)

  private override hash_code(recur):
    Equatable.hash_code_combine(recur(root),
                                for values(hc = 0):
                                  each i: 0 .. (tail :~ Array).length()
                                  Equatable.hash_code_combine(hc, tail.get(i)))

  // provide it i suppose even though it is slow (linear)
  private override append(rhs :~ Vector) :~ Vector:
    cond
    | size == 0: rhs
    | rhs.size == 0: this
    | ~else:
        recur f(i = 0, v :~ Vector = this, arr :~ PVec = array_for(0)):
          cond
          | i >= rhs.size:
              v
          | i >= rhs.size - rhs.tail_offset():
              for values(v = v :~ Vector):
                each a: (rhs.tail :~ Array)
                v.add(a)
          | i mod MAX_WIDTH == 0:
              let new_arr = array_for(i)
              f(i + 1, v.add(new_arr.get(0)), new_arr)
          | ~else:
              f(i + 1, v.add(arr.get(radix(i, 0))), arr)

        
  method add(el) :~ Vector:
    if size - tail_offset() < MAX_WIDTH
    | Vector(root, size + 1, shift, tail.add(el))
    | // is there room in current root without overflow to a new level?
      def overflow = (size bits.(>>) BITS) > (1 bits.(<<) shift)
      Vector(if overflow | Node(Array(root, new_branch(shift, tail)))
                         | // TODO something different if shift == 0
                           // or if root[0] == #false?
                           push_tail(shift, root, tail),
             size + 1,
             if overflow | shift + BITS
                         | shift,
             pvec(el))

  method add_all(seq :: Sequence) :~ Vector:
    for values(v = this):
      each val: seq
      v.add(val)
  


  override get(idx :: Int) :~ Vector:
    array_for(idx).get(idx bits.and MASK)

  method set(idx :: Int, el) :~ Vector:
    cond
    | idx < size && idx >= tail_offset():
        def new_tail = (tail :~ Array).copy()
        new_tail[idx bits.and MASK] := el
        Vector(root, size, shift, new_tail)
        
    | idx < size && idx >= 0:
        def new_root:
          recur set(level = shift, node :~ Node = root) :: Node:
            def data = node.data.copy()
            if level == 0
            | data[idx bits.and MASK] := el
            | def subidx = (idx bits.(>>) level) bits.and MASK
              data[subidx] := set(level - BITS, node.data[subidx])
              
            Node(data)
            
        Vector(new_root, size, shift, tail)
    | ~else: error(#'Vec, "index out of bounds")
        

  // TODO: sus! redo
  method take(pos :: Int) :~ Vector:
    cond
    | pos <= 0:
        EMPTY_VEC
    | pos >= size:
        this
    | pos > tail_offset():
        // we're just cutting some stuff off the tail in this case
        def new_tail_len = pos - tail_offset()
        def new_tail = Array.make(new_tail_len, #false)
        Array.copy_from(new_tail, 0, tail, 0, new_tail_len)
        Vector(root, pos, shift, new_tail)
    | ~else:
        def new_root = recur take(node :: Node = root, level = shift):
          def subidx = radix(size - 1, level)
          
          if level == 0
          | Node(node.data.take(subidx + 1))
          | def new_children = node.data.take(subidx + 1)
            new_children[subidx] := take(node.data[subidx], shift - BITS)
            Node(new_children)

        // TODO is this needed?
        recur squash(node :: Node = new_root, new_shift = shift):
          if !(node.data[1]) /* node.data.length() == 1
                                 ^- previous, but nodes always have len-32 backing arrays, nonexistent entries set to #false*/
            && new_shift > 0
          | squash(node.data[0], new_shift - BITS)
          | Vector(node, pos, new_shift, error("what to put as new tail?"))

  // TODO: sus! redo
  method drop(pos :: Int) :~ Vector:
    cond
    | pos <= 0:
        this
    | pos >= size:
        Vector()
    | size - pos <= tail.length():
        def new_tail = Array.make(size - pos, #false)
        Array.copy_from(new_tail, 0, tail, tail.length() - (size - pos))
        Vector(Node(), size - pos, 0, new_tail)
    | ~else:
        def new_root = recur drop(node :: Node = root, level = shift):
          def subindex = radix(pos, level)
          
          if level == 0
          | Node(node.data.drop(subindex))
          | def new_children = node.data.drop(subindex)
            def new_child = drop(node.data[subindex], level - BITS)
            new_children[0] := new_child
                
            Node(new_children)

        // TODO do i need this?
        recur squash(node :: Node = new_root, new_shift = shift):
          if !(node.data[1]) /* node.size == 1 */ && new_shift > 0
          | squash(node.data[0], new_shift - 5)
          | Vector(node, size - pos, new_shift, tail)

  method pop() :~ Vector:
    cond
    | size == 0:
        error(#'Vec, "cannot pop an empty vector")
    | size == 1:
        EMPTY_VEC
    | size - tail_offset() > 1:
        def new_tail = Array.make(tail.length() - 1)
        Array.copy_from(new_tail, 0, tail, 0, new_tail.length())
        Vector(root, size - 1, shift, new_tail)
    | ~else:
        def new_tail = array_for(size - 2)
        def new_root :: Node = pop_tail(shift, root) || Node()
        
        if shift > BITS && !(new_root.data[1])
        | Vector(new_root.data[0], size - 1, shift - BITS, new_tail)
        | Vector(new_root, size - 1, shift, new_tail)

  method split(at :: Int):
    match at
    | 0: values(Vector(), this)
    | size: values(this, Vector())
    | all where all = size: values(this, Vector())


  // TODO inefficient
  method to_list() :: List:
    for List:
      each i: 0 .. size
      get(i)

  property first: get(0)
  property last: tail[tail.length() - 1]
    

  /* helper methods */

  private method pop_tail(level :: Int, node :: Node) :: Node:
    def subidx = ((size - 2) bits.(>>) level) bits.and MASK
    cond
    | level > 5:
        def new_child = pop_tail(level - BITS, node.data[subidx])
        if !new_child && subidx == 0
        | #false
        | def data =node.data.copy()
          data[subidx] := new_child
          Node(data)
    | subidx == 0:
        #false
    | ~else:
        def data = node.data.copy()
        data[subidx] := #false
        Node(data)

  private method push_tail(level :: Int, parent :: Node, tail_node :: Array) :: Node:
    def subidx = ((size - 1) bits.(>>) level) bits.and MASK
    def data = parent.data.copy()

    data[subidx] := if level == BITS
    | Node(tail_node)
    | def child = parent.data[subidx]
      if child
      | push_tail(level - BITS, child, tail_node)
      | new_branch(level - BITS, tail_node)
      
    Node(data)

// todo private
 // private
  method tail_offset():
    if size < 32
    | 0
    | ((size - 1) bits.(>>) BITS) bits.(<<) BITS

// todo private
  //private method array_for(idx) :~ Vec:
  method array_for(idx) :~ PVec:
    cond
    | idx < 0 || idx >= size:
        error(#'Vector, "index out of bounds")
    | idx >= this.tail_offset():
        tail
    | ~else:
        recur step(node :~ Node = root, i = shift):
          if i == 0
          | node.data
          | step(node.data[(idx bits.(>>) i) bits.and MASK], i - BITS)


            
/* helper functions */



fun from(seq :: Sequence) :~ Vector:
  for values(v  = EMPTY_VEC :~ Vector):
    each el: seq
    v.add(el)
    
fun new_branch(level :~ Int, data :~ Array) :: Node:
  //if level == 0
  if level <= 0
  | Node(data)
  | Node(Array(new_branch(level - BITS, data)))

// TODO smarter way to do this?
fun calc_shift(v :~ Vector):
    calc_height(v :~ Vector) * BITS
fun calc_height(v :~ Vector):
    bits.length(math.max(0, v.size - v.tail.length() - MAX_WIDTH)) div BITS
def EMPTY_VEC :~ Vector = Vector[]

module test:
  check: EMPTY_VEC.add(1).to_list()
         ~is [1]

  let v :: Vector:
    for values(v = EMPTY_VEC):
      each i: 0 .. (MAX_WIDTH + 10)
      v.add(i)

  for (i: 0 .. MAX_WIDTH + 10):
    check: v.get(i)
           ~is i

  let v2 :: Vector = v.set(0, -1)
  check: v.get(0) ~is 0
         v2.get(0) ~is -1
         v.root.data[1] === v2.root.data[1] ~is #true

  let v  :: Vector = Vector.from(1..100)
  check: v.size ~is 99
         v.get(12) ~is 13

  check: v.set(99, -1)
         ~raises "out of bounds"

  let l :: List = List.iota(100)
  let v :: Vector = Vector.from(0..100)
  let idx = math.random(100)
 // let (ll, lr) = values(

  check: l.drop_right(100 - idx) ~is v.take(idx).to_list()
         l.drop_left(idx) ~is v.drop(idx).to_list()
         