#lang rhombus

import "rrbtree.rhm" open
import "rbtree.rhm"
import rhombus/measure
import lib("racket/base.rkt") as rkt:
  expose: #{time-apply}
  rename: #{time-apply} as rkt_time
import lib("racket/vector.rkt") as vec

/* TODO compare against
      - racket vectors
      - hash tables mapping indices to values
      - cons lists

   we care about small trees, time doing X operation multiple times (100 times)? not just once

  make sure to time:
      - constructors
      - 

  goals: 10s or 100s of milliseconds
*/
class TimeBenchmark(~cpu, ~real, ~gc):
  private implements Printable

  private override describe(mode, recur):
    "~cpu: " +& cpu +& ", ~real: " +& real +& ", ~gc: " +& gc
  

fun time(f, args) :~ TimeBenchmark:
  let (_, cpu, real, gc) = rkt_time(f, args)
  TimeBenchmark(~cpu: cpu, ~real: real, ~gc: gc)

macro 'times($f, $objs)':
  'for Map:
     each obj: $objs
     values(sizeof(obj), time($f, [obj]))'

macro 'bench ($name = $obj):
         ~times: $iterations
         $exp':
  'time(fun ($name):
          for (i: 0 .. $iterations):
            $exp,
        [$obj])'

class Timings(~list,
              ~rrb,
              ~rb,
              ~hash,
              ~rkt_vec,
              ~control,
              ~op,
              ~size,
              ~iters)

macro 'bench_for $op times $iters with name $name and size $sz:
         $_list: $_list_exp
         $_rrb: $_rrb_exp
         $_rb: $_rb_exp
         $_hash: $_hash_exp
         $_rkt_vec: $_rkt_vec_exp':
  'bench ($name = $_rrb):
     ~times: $iters
     $_rrb_exp'
  #//
  'block:
     let (lst, rrb, rb, hsh, rkt_vec, control):
       values(
         bench ($name = $_list):
           ~times: $iters
           $_list_exp,
         bench ($name = $_rrb):
           ~times: $iters
           $_rrb_exp,
         bench ($name = $_rb):
           ~times: $iters
           $_rb_exp,
         bench ($name = $_hash):
           ~times: $iters
           $_hash_exp,
         bench ($name = $_rkt_vec):
           ~times: $iters
           $_rkt_vec_exp,
         bench ($name = #false):
           ~times: $iters
           #void)
     Timings(~list: lst,
             ~rrb: rrb,
             ~rb: rb,
             ~hash: hsh,
             ~rkt_vec: rkt_vec,
             ~op: $op,
             ~iters: $iters,
             ~size: $sz,
             ~control: control)'

def small_sizes = [1, 5, 10, 50, 100, 300, 500]
def sizes = [1, 5, 10, 50, 100, 300, 500, 1000, 10000]
def short_iters = 1000
def iters = 10000
def long_iters = 1000000

def small_ctor_times:
  for Map:
    each sz: small_sizes
    values(sz,
           bench_for "ctor" times iters with name t and size sz:
             #void: List.iota(sz)
             #void: Vec().add_all(List.iota(sz))
             #void: rbtree.Vector.from(0..sz)
             #void: for Map (i: 0 .. sz):
                      values(i, i)
             #void: for Array ~length sz (i: 0 .. sz):
                      i
           )

def ctor_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "ctor" times short_iters with name t and size sz:
             #void: List.iota(sz)
             #void: Vec().add_all(List.iota(sz))
             #void: rbtree.Vector.from(0..sz)
             #void: for Map (i: 0 .. sz):
                      values(i, i)
             #void: for Array ~length sz (i: 0 .. sz):
                      i
           )

def snoc_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "snoc" times iters with name t and size sz:
             (List.iota(sz)): t.append(["foo"])
             (Vec().add_all(List.iota(sz))): t.add("foo")
             (rbtree.Vector.from(0..sz)): t.add("foo")
             (for Map (i: 0..sz): values(i, i)): t ++ { sz: "foo" }
             (rkt.#{list->vector}(List.iota(sz))): vec.#{vector-append}(t, rkt.vector("foo"))
           )

def cons_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "cons" times short_iters with name t and size sz:
             (List.iota(sz)): List.cons("foo", t)
             (Vec().add_all(List.iota(sz))): t.insert(0, "foo")
             (rbtree.Vector.from(0..sz)): for values(v = rbtree.Vector().add("foo")):
                                            each i: 0..sz
                                            v.add(t.get(i))
             (for Map (i: 0..sz): values(i, i)): (for Map:
                                                    each (k, v): t
                                                    values(k+1, v)) ++ { 0: "foo" }
             (rkt.#{list->vector}(List.iota(sz))): vec.#{vector-append}(rkt.vector("foo"), t)
           )

def add_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "add" times long_iters with name t and size sz:
             (List.iota(sz)): List.cons("foo", t)
             (Vec().add_all(List.iota(sz))): t.add("foo")
             (rbtree.Vector.from(0..sz)): t.add("foo")
             (for Map (i: 0..sz): values(i, i)): t ++ { sz: "foo" }
             (rkt.#{list->vector}(List.iota(sz))): vec.#{vector-append}(t, rkt.vector("foo"))
           )

def concat_times:
  for Map:
    each sz: sizes
    values(sz,
           bench_for "++" times short_iters with name t and size sz:
             (List.iota(sz)): t ++ t
             (Vec().add_all(List.iota(sz))): t ++ t
             (rbtree.Vector.from(0..sz)): for values(v = t):
                                            each i: 0..sz
                                            v.add(t.get(i))
             (for Map (i: 0..sz): values(i, i)): for values(new_t = t):
                                                    each (k, v): t
                                                    new_t ++ { k+sz: v }
             (rkt.#{list->vector}(List.iota(sz))): t ++ t
           )

"small_ctor"
small_ctor_times
"ctor"
ctor_times
"snoc"
snoc_times
"cons"
cons_times
"add"
add_times
"concat"
concat_times
