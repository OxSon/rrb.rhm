#lang rhombus/static

import "utils.rhm" open

export:
  Vec

def SHIFT_INC = 5
def MAX_WIDTH = 32
def SHIFT_MASK = 31
def MAX_ERROR = 2


/* a node in the RRB Tree

  - a node is fully dense if it has exactly `m` children where `m` is the branching factor of the overall Tree
    and each child is also fully dense
  - a node is leftwise dense if its first `n - 1` children, where `n` is its total number of children,
    are fully dense, and its `n`th child is leftwise-dense or fully dense. `n` is allowed to be < `m`
  - a node is balanced if it is leftwise dense or fully dense (note that leaves are always at least leftwise dense)
  - unbalanced nodes contain a size array `sizes`, balanced nodes do not
*/
class Node(children :~ Array.of(Node || Any) = vec(), sizes :~ Array.of(Int/*:~ maybe(Array.of(Int)*/) = #false):
  private implements Equatable
 
  property balanced:
    !sizes
    
  property size:
    children.length()

  property first:
    children[0]

  property last:
    children[children.length() - 1]


  private override equals(rhs :~ Node, recur):
    children.length() == rhs.children.length()
      && (for values(eq = #true):
            each i: 0 .. children.length()
            break_when !eq
            recur(children[i], rhs.children[i]))

  private override hash_code(recur):
    if children.length() == 0
    | 0
    | for values(hc = recur(children[0])):
        each i: 1 .. children.length()
        Equatable.hash_code_combine(hc, recur(children[i]))
    
  method get(index):
    children[index]

  method set(index, el) :~ Node:
    Node(set_vec(children, index, el), sizes)



macro 'leaf($args)':
  'Node(vec($args))'

// TODO
def dummy_node = leaf("todo")

macro 'EMPTY_VEC': 'CVec[]'

                    
class CVec(root :~ Node,
           size :~ NonnegInt,
           height :~ NonnegInt,
           tail :: Array):
  implements Indexable
  private implements Equatable
  private implements Appendable

  
  internal _CatVec

  //what about making rrbtree the default but having it return
  // a list for smaller values? perhaps up to dozens?
  // would need to unify their apis, though

// NOTE: I want to go look at the source of List.iota.
  // this should be easy to do from the docs
  expression
  // TODO smaller (shift <= 5?) CVecs are just Vecs until cloned/catted/operated on?
  | 'CVec[]': '_CatVec(Node(), 0, 0, vec()) :~ CVec'
  | 'CVec[$(a :: Term)]': '_CatVec(Node(), 1, 0, vec($a))'
  | 'CVec[$a, $b]': '_CatVec(Node(), 2, 0, vec($a, $b))'
  | 'CVec[$a, $b, $c]': '_CatVec(Node(), 3, 0, vec($a, $b, $c)) :~ CVec'
  | 'CVec[$a, $b, $c, $d, ...]': 'CVec[$a, $b, $c].add_all(List($d, ...)) :~ CVec'
  | 'CVec()': '_CatVec(Node(), 0, 0, vec()) :~ CVec'
  | 'CVec(~from: $lst)': '_CatVec(Node(), 0, 0, vec()).add_all($lst)'
  | 'CVec($root, $size, $height, $tail)': '_CatVec($root, $size, $height, $tail) :~ CVec'

 #//
  def from:
    fun (& lst):
      match lst
      | []: CVec[]
      | List.cons()

  #//
  reconstructor (root):
    error("todo")
  
  property balanced:
    root.balanced

  private override equals(rhs :~ CVec, recur):
    size == rhs.size && recur(root, rhs.root)

  private override hash_code(recur):
    recur(root)

  private method tail_offset():
    cond
    | root.balanced && size > 32:
        ((size - 1) bits.(>>) SHIFT_INC) bits.(<<) SHIFT_INC
    | size > 32:
        root.sizes[root.sizes.length() - 1]
    | ~else: 0

  // get the element at `index`
  override get(index :~ Int):
    if index >= tail_offset()
    | tail[radix_of(index, 0)]
    | recur get(node :~ Node = root, index = index, depth = height):
        if node.balanced
        | for values(n = node):
            each i: 0 .. depth + 1
            n.get(radix_of(index, depth - i))
        | def (branch_index, subindex) = step(node, index, depth)
          get(node.get(branch_index), subindex, depth - 1)

  // functionally update the slot at `index` to `el`
  method set(index :~ Int, el):
    if index >= tail_offset()
    | CVec(root, size, height, set_vec(tail, index, el))
    | def new_node = recur set(node :~ Node  = root, index = index, el = el, depth = height):
        cond
        | depth == 0:
            node.set(radix_of(index, depth), el)
        | node.balanced:
            def branch_index = radix_of(index, depth)
            node.set(branch_index, set(node.get(branch_index), index, el, depth - 1))
        | ~else:
            def (branch_index, subindex) = step(node, index, depth)
            node.set(branch_index, set(node.get(branch_index), subindex, el, depth - 1))

      CVec(new_node, size, height, Node(vec("todo")))

  // trees that are a result of this method may not meet invariants, but rebalancing is costly
  // and future concatenations would restore the invariants due to rebalancing being done on concats.
  // TODO write some tests showing this
  method take(pos :~ NonnegInt) :~ CVec:
    cond
    | pos <= 0:
        CVec[]
    | pos >= size:
        this
    | ~else:
        def new_root = recur take(node :~ Node = root, index = pos - 1, depth = height):
          cond
          | depth == 0:
              Node(unsafe.freeze_vec(vec_take(node.children, radix_of(index, 0) + 1)))
          | node.balanced:
              def branch_index = radix_of(index, depth)
              def new_children :~ Array.of(Node) = vec_take(node.children, branch_index + 1)
              new_children[branch_index] := take(node.get(branch_index), index, depth - 1)
              Node(unsafe.freeze_vec(new_children))
          | ~else:
              def (branch_index, subindex) = step(node, index, depth)
              def new_children :~ Array.of(Node) = vec_take(node.children, branch_index + 1)
              def new_sizes :~ Array.of(Int)  = vec_take(node.sizes, branch_index + 1)
              new_children[branch_index] := take(node.get(branch_index), subindex, depth - 1)
              new_sizes[branch_index] := index + 1
              Node(unsafe.freeze_vec(new_children),
                   unsafe.freeze_vec(new_sizes))

        recur squash(node :~ Node = new_root, new_height = height):
          if node.size == 1 && new_height > 0
          | squash(node.first, new_height - 1)
          | CVec(node, pos, new_height, dummy_node)
        

  method drop(pos :~ NonnegInt) :~ CVec:
    cond
    | pos <= 0:
        this
    | pos >= size:
        CVec[]
    | ~else:
        def new_root = recur drop(node :~ Node = root, index :~ Int = pos, depth :~ Int = height) :~ Node:
          cond
          | depth == 0:
              Node(unsafe.freeze_vec(vec_drop(node.children, radix_of(index, 0))))
          | node.balanced:
              def branch_index = radix_of(index, depth)
              def new_children :~ Array.of(Node) = vec_drop(node.children, branch_index)
              def new_child :~ Node = drop(node.get(branch_index), index, depth - 1)
              new_children[0] := new_child
              
              def size0 :~ Int:
                if depth == 1 || new_child.balanced
                | (1 bits.(<<) (depth * SHIFT_INC)) - radix_of(index, depth - 1)
                | (new_child.sizes :~ Array.of(Int))[new_child.size - 1]
              def new_len = node.size - branch_index    
              def step = 1 bits.(<<) (depth * SHIFT_INC)
              def new_sizes = Array.make(new_len)
              
              for (i: 0 .. new_sizes.length()):
                new_sizes[i] := (size0 + i * step)
                
              Node(unsafe.freeze_vec(new_children),
                   unsafe.freeze_vec(new_sizes))
          | ~else:
              def (branch_index, subindex) = step(node, index, depth)
              def new_children :~ Array.of(Node) = vec_drop(node.children, branch_index)
              def new_sizes = for Array:
                each i: branch_index .. (node.sizes :~ Array.of(Int)).length()
                (node.sizes :~ Array.of(Int))[i] - index 
              def new_child = drop(node.get(branch_index), subindex, depth - 1)
                
              new_children[0] := new_child  
              Node(unsafe.freeze_vec(new_children),
                   unsafe.freeze_vec(new_sizes))

        def t :~ CVec:
          recur squash(node :~ Node = new_root, new_height = height):
            if node.size == 1 && new_height > 0
            | squash(node.first, new_height - 1)
            | CVec(node, size - pos, new_height, dummy_node)

        // TODO explain
        if t.height > 1 && t.root.sizes
        | def sizes = set_vec(t.root.sizes, t.root.size - 1, t.size)
          CVec(Node(t.root.children, sizes), t.size, t.height, dummy_node) 
        | t

// TODO use :~
  private method pushdown_tail(node :: Node, t :: Array, size, height, cc) :: CVec:
    if height == 1
    | #void
    | #void
          

  // add `el` to end of vector
  method add(el) :~ CVec:
    if tail.length() != MAX_WIDTH
    | CVec(root, size + 1, height, add_vec(tail, el))
    | def count = copyable_count(root, height)
      if count == 0
      | /* not enough space in original tree */
        CVec(Node(vec(
                   new_branch_node(root, tail, height), size + 1, height + 1,
                   root.sizes && vec(size - tail.length(), tail.length()))),
             size + 1,
             height + 1,
             vec(el))
      | /* enough space in original tree */
        pushdown_tail(root, tail, size, height, count)

  macro 'construct($args, ...)':
    'for values(t = CVec[]):
      each:
        el: (($args, ...) :~ Array)
      t.add(el)'
    
  export:
    construct

    

// TODO chunk adding here by 32 and add whole nodes at a time?
  method add_all(els :~ Sequence) :~ CVec:
    #//
    for values(t = CVec[]):
      each el: els
      def a = for Array:
        each i: 0 .. 32
        el
        
      t.add_node(unsafe.freeze_vec(a), a.length())
      
        
    
    for values(t = this):
      each:
        el: els
      t.add(el)

  method add_node(node, sz) :~ CVec:
    def count = copyable_count(root, height)
    if count == 0
    | CVec(Node(vec(root, node),
                root.sizes && vec(size, size + sz)),
           size + sz,
           height + 1,
           dummy_node)
    | CVec(build_node(root, count, height, node, sz),
           size + sz,
           height, dummy_node)

  // TODO can't annotate multiple return values ?
  method split(at :~ NonnegInt):/*~ (Vec, CVec)*/
    cond
    | at == 0: values(CVec[], this)
    | at == size: values(this, CVec[])
    | at > 0 && at < size: values(take(at), drop(at))
    | ~else: error(#'split, "invalid index")
    

  private override method append(rhs :~ CVec):
    concat(rhs)
    
  method concat(rhs :~ CVec) :~ CVec:
    cond
    | size == 0: rhs
    | rhs.size == 0: this
    | ~else:
        calc_height_and_wrap(
          concat_subtree(root,
                         height,
                         rhs.root,
                         rhs.height,
                         #true),
          size + rhs.size)

  method insert(at :~ NonnegInt, el) :~ CVec:
    cond
    | at <= 0:
        CVec[].add(el).concat(this)
    | at >= size - 1:
        this.add(el)
    | ~else:
        let (l :~ CVec, r :~ CVec) = split(at)
        l.add(el).concat(r)

  // TODO shoudl be able to make this faster. At the least, we can grab whole leaf nodes at a time 
  // rather than traverse once per element of represented vector
  method to_list() :~ List:
    for List:
      each idx: 0..size
      get(idx)




fun concat_subtree(left :~ Node,
                   height_l :~ Int,
                   right :~ Node,
                   height_r :~ Int,
                   top :~ Boolean) :~ Node:
  cond
  /* only trees of the same height can be concatenated */
  | height_l > height_r:
      rebalance(left,
                concat_subtree(left.last,
                               height_l - 1,
                               right,
                               height_r,
                               #false),
                #false,
                height_l,
                top)
  | height_l < height_r:
      rebalance(#false,
                concat_subtree(left,
                               height_l,
                               right.first,
                               height_r - 1,
                               #false),
                right,
                height_r,
                top)
  | height_l == 0:
      if top && left.size + right.size <= MAX_WIDTH
      | Node(append_vec(left.children, right.children))
      | set_sizes(vec(left, right), 1)
  | ~else:
      /* two internal nodes with same height */
      rebalance(left,
                concat_subtree(left.last,
                               height_l - 1,
                               right.first,
                               height_r - 1,
                               #false),
                right,
                height_l,
                top)

fun rebalance(left :~ maybe(Node),
              center :~ Node,
              right :~ maybe(Node),
              height :~ Int,
              top :~ Boolean) :~ Node:
  def all_slots = merge_nodes(left, center, right)
  def plan = concat_plan(all_slots)
  def rebalanced_slots = exec_concat_plan(all_slots, plan, height)

  cond
  | rebalanced_slots.length() <= MAX_WIDTH && !top:
      Node(vec(set_sizes(unsafe.freeze_vec(rebalanced_slots), height)))
  | rebalanced_slots.length() <= MAX_WIDTH:
      set_sizes(unsafe.freeze_vec(rebalanced_slots), height)
  | ~else:
      def (new_left :~ Array, new_right :~ Array) = vec_split(rebalanced_slots, MAX_WIDTH)
      set_sizes(vec(set_sizes(unsafe.freeze_vec(new_left), height),
                    set_sizes(unsafe.freeze_vec(new_right), height)),
                height + 1)
                   

/* merge all children except for the rightmost in `left` and leftmost in `right` */
fun merge_nodes(left :~ Node/*:~ maybe(Node)*/, center :~ Node, right :~ Node/* :~ maybe(Node)*/) :~ Array:
  array_append(if !left || left.size == 0 | vec() | vec_drop_right(left.children, 1),
               center.children,
               if !right || right.size == 0 | vec() | vec_drop(right.children, 1))

// TODO how to avoid setting sizes when the tree is leftwise dense?
fun set_sizes(children :~ Array, height :~ Int) :~ Node:
  if height == 0
  | Node(children)
  | // TODO do this more efficiently
    def (sizes, _):
      for values(sizes = vec(), sum = 0):
        each i: 0 .. children.length()
        def child_size =  size_subtree(children[i], height - 1)
        values(add_vec(sizes, sum + child_size),
               sum + child_size)
             

    Node(children, sizes)


// TODO redesign this to be less imperative?
/* receives a node that is temporarily allowed to have > max_width children, redistributes it to conform to invariant */
fun concat_plan(slots :~ Array.of(Node)) :~ maybe(Array):
  def plan = Array.make(slots.length())
  def child_count:
    for values(count = 0):
      each i: 0 .. slots.length()
              
      plan[i] := (slots[i] :~ Node).size
      count + plan[i]

  def optimal_node_len = math.ceiling(child_count / MAX_WIDTH)
  def target_node_len = optimal_node_len + MAX_ERROR
  
  if target_node_len >= plan.length()
  | #false
  | distribute(plan.copy(), target_node_len, plan.length())
             
fun distribute(plan :~ Array, target :~ Int, count :~ Int, node_idx :~ Int = 0) :~ Array:
  if target >= count:
  | vec_take(plan, count)
  | let i = short_node(plan, node_idx)
    let (i, r):
      // TODO better way to do this?
      for values(i = short_node(plan, node_idx),
                 r = plan[i]):
        each _: 0..
        final_when r == 0
        def min_size = math.min(r + plan[i + 1], MAX_WIDTH)
        plan[i] := min_size
        values(i + 1, r + plan[i + 1] - min_size)

    /* we've removed a node (conceptually) at this point,
    so move nodes to the right of current node left by one */
    for (j: i .. count - 1):
      plan[j] := plan[j + 1]

    distribute(plan, target, count - 1, i - 1)


fun short_node(plan :~ Array, i :~ Int) :~ Int:
  if plan[i] < MAX_WIDTH - 1
  | i
  | short_node(plan, i + 1)


fun exec_concat_plan(slots :~ Array.of(Node),
                     plan :~ Array /* :~ maybe(Array)*/,
                     height :~ Int) :~ Array:
  if !plan
  | slots
  | def flattened:
      for Array:
        each node :~ Node: slots
        each child :~ Node: node.children
        child
        
    def new_slots = Array.make(plan.length())
    for values(sum = 0):
      each i: 0..plan.length()
              
      let new_sum = sum + plan[i]
      let new_node:
        for Array:
          each j: sum .. new_sum
          flattened[j]
      new_slots[i] :=  set_sizes(unsafe.freeze_vec(new_node), height - 1)
      
      new_sum
             
    new_slots



// TODO can we calculate this along the way and get rid of this extra traversal?
fun calc_height_and_wrap(root :~ Node, size :~ Int):
  def (_, height):
    for values(node = root, height = 0):
      each i: 0..
      break_when !(node is_a Node)
      values(node.first, i)
    
  CVec(root, size, height, dummy_node)

/* TODO: is this a bug waiting to happen?
  We're calling this to set sizes and then assuming we can
  rely on the presence of sizes array already.
  seems to work except for in case of right-most child of root node,
  which we are currently correcting for in concat
*/
fun size_subtree(node :~ Node, height :~ Int):
  cond
  | height == 0:
      node.children.length()
  | node.sizes:
      node.sizes[node.size - 1]
  | ~else: // if sizes is #false, then we know we have a leftwise-dense subtree TODO: do we though?
      ((node.size - 1) bits.(<<) (height * SHIFT_INC)) + size_subtree(node.last, height - 1)
      

/* helper functions */
      
fun radix_of(index :~ Int, height :~ Int) :~ Int:
  (index bits.(>>) (SHIFT_INC * height)) bits.and SHIFT_MASK
                      
fun scan_sizes(sizes :~ Array, target_index, i = 0) :~ Int:
  if sizes[i] <= target_index
  | scan_sizes(sizes, target_index, i + 1)
  | i

// calculate next branch to take and subindex of `index` along that path
fun step(node :~ Node, index, depth) :~ (NonnegInt, NonnegInt):
  def branch = scan_sizes(node.sizes, index, radix_of(index, depth))
  values(branch,
         if branch == 0
         | index
         | index - node.sizes[branch - 1])

// count number of nodes that either have room themselves for another element and/or branch,
// or one of their right-most descendents has room
  
// TODO very large trees (larger than 32^3) tend to go OOM in this function.
// is there a more efficient way tod o this? Perhaps just assume there's room in the tree
// and check properties of the generated new_root to see if that's correct or not?
fun copyable_count(node :~ Node, height):
  def (_, count):
    for values(n = node, count = 0):
      each i: 0 .. height + 1
      def l = n.size
      values(if l == 0
             | n
             | n.get(l - 1),
             if l < MAX_WIDTH
             | i + 1
             | count)
  count


//  using `count` returned from `copyable_count`, copy `count` nodes along right-most path of `n`,
// then insert new element in leaf node or new branch if `count` << `height`
fun build(n :~ Node, count, height, el):
  if count < 2
  | if height == 0
    | Node(add_vec(n.children, el))
    | Node(add_vec(n.children,
                   new_branch(el, height - 1)))
  | Node(set_vec(n.children,
                 n.size - 1,
                 build(n.get(n.size - 1),
                       count - 1,
                       height - 1,
                       el)),
         n.sizes && set_vec(n.sizes,
                            n.sizes.length() - 1,
                            n.sizes[n.sizes.length() - 1] + 1))

//  using `count` returned from `copyable_count`, copy `count` nodes along right-most path of `n`,
// then insert new node
fun build_node(n :~ Node, count, height, node, sz):
  if count < 2
  | if height == 0
    | Node(node)
    | Node(add_vec(n.children, node))
  | Node(set_vec(n.children,
                 n.size - 1,
                 build_node(n.get(n.size - 1),
                            count - 1,
                            height - 1,
                            node,
                            sz)),
         n.sizes && set_vec(n.sizes,
                            n.sizes.length() - 1,
                            n.sizes[n.sizes.length() - 1] + sz))
  #//
  if count < 2
  | if height == 0
    | Node(add_vec(n.children, el))
    | Node(add_vec(n.children,
                   new_branch(el, height - 1)))
  | Node(set_vec(n.children,
                 n.size - 1,
                 build(n.get(n.size - 1),
                       count - 1,
                       height - 1,
                       el)),
         n.sizes && set_vec(n.sizes,
                            n.sizes.length() - 1,
                            n.sizes[n.sizes.length() - 1] + 1))

// create a branch of height `height` terminating in a unary leaf node containing `el`
fun new_branch(el, height):
  if height == 0
  | leaf(el)
  | Node(vec(new_branch(el, height - 1)))

// TODO
fun new_branch_node(node :~ Node, t :~ Array, height):
  // wrong
  if height == 0
  | Node(node, t)
  | Node(vec(new_branch_node(node, t, height - 1)))

fun calc_height(v :~ CVec):
    bits.length(math.max(0,
                         v.size /* TODO add when tail optimzation done- v.tail.length() */
                           - MAX_WIDTH)) div SHIFT_INC


// TODO use what we know about CVec invariants and size of `from`
// to construct the vector in a smarter fashion
fun mk_vec(from :~ List) :~ CVec:
  fun calc_height(size :~ Int, tail_len :~ Int):
      bits.length(math.max(0,
                           size - tail_len /* TODO add when tail optimzation done- v.tail.length() */
                             - MAX_WIDTH)) div SHIFT_INC

  if from.length() <= 32
  | CVec(Node(),
         from.length(),
         calc_height(from.length(), from.length() mod 32),
         unsafe.freeze_vec(for Array:
                             each el: from
                             el))
  | recur go(l :~ List = from, acc :~ Array = vec(), node :~ Array = vec(), h = 0):
      match l
      | []:  CVec(Node(acc), from.length(), calc_height(from.length(), from.length() mod 32), node)
      | List.cons(el, rst):
          cond
          | node.length() == MAX_WIDTH
              && acc.length() == MAX_WIDTH:
                go(rst, vec(Node(acc), new_branch(el, h)), vec(), h + 1)
          | node.length() == MAX_WIDTH:
              go(rst, add_vec(acc, Node(node)), vec(), h)
          | ~else: go(rst, acc, add_vec(node, el), h)
