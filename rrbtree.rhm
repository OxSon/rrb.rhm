#lang rhombus

import "utils.rhm" open
import "stv_compat.rhm" open

export:
  Tree


/* a node in the RRB Tree
  - a node is balanced if it is a leaf, or if its first `n - 1` children each have exactly `m`
    children where `m` is the branch factor of the containing `Tree` and `n = len(children)`
  - unbalanced nodes contain a size array `sizes`, balanced nodes do not
*/
class Node(children :: Vec = vec(), sizes :: Vec || False = #false):
  private implements Equatable
 
  property balanced:
    !sizes
    
  property size:
    len(children)

  property first:
    first_vec(children)

  property last:
    last_vec(children)

  property init:
    Node(init_vec(children),
         sizes && init_vec(sizes))

  property tail:
    Node(tail_vec(children),
         sizes && (for values(v = vec()):
                     def shrink_by = ref(sizes, 0)
                     each i: 1..len(sizes)
                     add_vec(v, ref(sizes, i) - shrink_by)))

  private override equals(rhs :: Node, recur):
    len(children) == len(rhs.children)
      && (for values(eq = #true):
            each i: 0..len(children)
            break_when !eq
            recur(ref(children, i), ref(rhs.children, i)))

  private override hash_code(recur):
    if len(children) == 0
    | 0 // TODO is this an ok hash code?
    | for values(hc = recur(ref(children, 0))):
        each i: 1..len(children)
        Equatable.hash_code_combine(hc, recur(ref(children, i)))
    
  method get(index):
    ref(children, index)

  method set(index, el) :~ Node:
    Node(set_vec(children, index, el), sizes)

    
fun leaf(args, ...) :~ Node:
  Node(vec(args, ...))
  
module test:
  check:
    Node(vec(1, 2, 3)).get(2)
    ~is 3

  check:
    Node(vec(1, 2, 3))
    ~is Node(vec(1, 2, 3))

  check:
    Node(vec(leaf(1), leaf(2, 3)),
         vec(1, 3))
    ~is Node(vec(leaf(1), leaf(2, 3)))

  let t1 = Node(vec(Node(vec(0, 1)), Node(vec(2, 3))), vec(2, 4))
  let t2 = t1.set(0, t1.get(0).set(0, -1))
  check: t2
         ~is Node(vec(Node(vec(-1, 1)), Node(vec(2, 3))), vec(2, 4))

  check: t1.sizes === t2.sizes
         ~is #true

  check: t1.get(1) === t2.get(1)
         ~is #true

  check: leaf(1, 2, 3)
         ~is Node(vec(1, 2, 3))

  check: Node(vec(leaf(1, 2), leaf(3))).init
         ~is Node(vec(leaf(1, 2)))
  check: leaf(1, 2, 3, 4).tail
         ~is Node(tail_vec(vec(1, 2, 3, 4))) // leaf(2, 3, 4)
  check: leaf(1, 2, 3, 4).init
         ~is Node(init_vec(vec(1, 2, 3, 4))) // leaf(1, 2, 3)

  check: Node(vec(
                leaf(1, 2, 3),
                leaf(4, 5, 6))).init.last
         ~is leaf(1, 2, 3)

  check: Node(vec(
                leaf(1, 2, 3),
                leaf(4, 5, 6, 7))).tail.first
         ~is leaf(4, 5, 6, 7)

  check: Node(vec(
                leaf(1),
                leaf(2, 3)),
              vec(1, 3)).tail
         ~is Node(vec(leaf(2, 3)))

  check: Node(vec(
                leaf(1, 2, 3, 4),
                leaf(4, 5, 6),
                leaf(7, 8, 9, 10)),
              vec(4, 7, 11)).tail
         ~is Node(vec(leaf(4, 5, 6),
                      leaf(7, 8, 9, 10)),
                  vec(3, 7))

  check: Node(vec(leaf(1),
                  leaf(2, 3),
                  leaf(4, 5)),
              vec(1, 3, 5)).init
         ~is Node(vec(leaf(1),
                      leaf(2, 3)),
                  vec(1, 3))

// TODO: allowing an arbitrary branch factor is nice for testing, but is probably unnecessary in the final implementation,
// and complicates implementation slightly in some places
class Tree(root :: Node = Node(),
           size :: NonnegInt = 0,
           height :: NonnegInt = 0,
           branch_factor = bits.length(VEC_WIDTH) - 1,
           private max_width = 1 bits.(<<) branch_factor):
  private implements Equatable

  property balanced:
    root.balanced
    
  property width:
    max_width

  private override equals(rhs :: Tree, recur):
    size == rhs.size && recur(root, rhs.root)

  private override hash_code(recur):
    recur(root)

  // get the element at `index`
  method get(index :: Int):
    recur get(node = root, index = index, depth = height):
      if node.balanced
      | for values(n = node):
          each i: 0 .. depth + 1
          n.get(radix_of(index, branch_factor, depth - i))
      | def (branch_index, subindex) = step(node, index, branch_factor, depth)
        get(node.get(branch_index), subindex, depth - 1)

  // set the slot at `index` to `el`
  method set(index :: Int, el) :~ Tree:
    def new_node = recur set(node = root, index = index, el = el, depth = height):
      cond
      | depth == 0:
          node.set(radix_of(index, branch_factor, depth), el)
      | node.balanced:
          def branch_index = radix_of(index, branch_factor, depth)
          node.set(branch_index, set(node.get(branch_index), index, el, depth - 1))
      | ~else:
          def (branch_index, subindex) = step(node, index, branch_factor, depth)
          node.set(branch_index, set(node.get(branch_index), subindex, el, depth - 1))

    Tree(new_node,  size,  height,  branch_factor)


  // add `el` to end of vector
  method add(el) :~ Tree:
    def count = copyable_count(root, width, height)
    if count == 0
    | /* not enough space in original tree */
      Tree(Node(vec(root, new_branch(el, height)),
                root.sizes && vec(size, size + 1)),
           size + 1,
           height + 1,
           branch_factor)
    | /* enough space in original tree */
      Tree(build(root, count, height, el),
           size + 1,
           height,
           branch_factor)
          
                
  method concat(rhs :: Tree) :~ Tree:
    TODO "concat"
  
  method split(at :: NonnegInt, side :: Any.of(#'left, #'right, #'l, #'r)) :~ Tree:
    TODO "split"

module test:
  check: Tree()
         ~is Tree()

  check: Tree(leaf(1, 2, 3), 3, 0, 4)
         ~is Tree(leaf(1, 2, 3), 3, 0, 32)


/* helper functions */

fun radix_of(index :: Int, branch_factor, height) :~ Int:
  if height == 0
  | index bits.and ((1 bits.(<<) branch_factor) - 1)
  | (index bits.(>>) (branch_factor * height)) bits.and ((1 bits.(<<) branch_factor) - 1)
                      
fun scan_sizes(sizes, target_index, i = 0) :~ Int:
  if ref(sizes, i) <= target_index
  | scan_sizes(sizes, target_index, i + 1)
  | i

// calculate next branch to take and subindex of `index` along that path
fun step(node :: Node, index, branch_factor, depth) :~ (NonnegInt, NonnegInt):
  def branch = scan_sizes(node.sizes, index, radix_of(index, branch_factor, depth))
  values(branch,
         if branch == 0
         | index
         | index - ref(node.sizes, branch - 1))

// count number of nodes that either have room themselves for another element and/or branch,
// or one of their right-most descendants has room
fun copyable_count(node, width, height):
  def (_, count):
    for values(n = node, count = 0):
      each i: 0 .. height + 1
      def l = n.size
      values(if l == 0
             | n
             | n.get(l - 1),
             if l < width
             | i + 1
             | count)
  count



//  using `count` returned from `copyable_count`, copy `count` nodes along right-most path of `n`,
// then insert new element in leaf node or new branch if `count` << `height`
fun build(n, count, height, el):
  if count < 2
  | if height == 0
    | Node(add_vec(n.children, el))
    | Node(add_vec(n.children,
                   new_branch(el, height - 1)))
  | Node(set_vec(n.children,
                 n.size - 1,
                 build(n.get(n.size - 1),
                       count - 1,
                       height - 1,
                       el)),
         n.sizes && set_vec(n.sizes,
                            len(n.sizes) - 1,
                            ref(n.sizes, len(n.sizes) - 1) + 1))

// create a branch of height `height` terminating in a unary leaf node containing `el`
fun new_branch(el, height):
  if height == 0
  | leaf(el)
  | Node(vec(new_branch(el, height - 1)))



module test:
  check: Tree(leaf(), 0, 0).add(0)
         ~is Tree(leaf(0), 1, 0)
  check: Tree(leaf(0), 1, 0, 1).add(1)
         ~is Tree(leaf(0, 1), 2, 0, 1)
  check: Tree(leaf(0, 1), 2, 0, 1).add(2)
         ~is Tree(Node(vec(leaf(0, 1), leaf(2))), 3, 1, 1)
  check: Tree(Node(vec(leaf(0), leaf(1)), vec(1, 2)), 2, 1, 1).add(2)
         ~is Tree(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)), 3, 1, 1)

  check: (Tree(
           Node(
             vec(Node(vec(leaf(0, 1), leaf(2))),
                 Node(vec(leaf(3, 4), leaf(5, 6)))),
             vec(3, 7)
           ),
           7, 2, 1)
          ).add(7)
         ~is Tree(
           Node(vec(
                  Node(
                    vec(Node(vec(leaf(0, 1), leaf(2))),
                        Node(vec(leaf(3, 4), leaf(5, 6)))),
                    vec(3, 7)
                  ),
                  Node(
                    vec(Node(vec(leaf(7)))))),
                vec(7, 8)),
           8, 3, 1)

  let t = Tree(
    Node(
      vec(
        Node(vec(leaf(0,   1,  2,  3),
                 leaf(4,   5,  6,  7),
                 leaf(8,   9, 10, 11),
                 leaf(12, 13, 14))),
        Node(vec(leaf(15, 16, 17, 18),
                 leaf(19, 20, 21, 22),
                 leaf(23, 24, 25, 26),
                 leaf(27, 28, 29, 30))),
        Node(vec(leaf(31, 32, 33, 34),
                 leaf(35, 36, 37, 38),
                 leaf(39, 40, 41, 42),
                 leaf(43, 44, 45, 46))),
        Node(vec(leaf(47, 48, 49, 50),
                 leaf(51, 52, 53, 54),
                 leaf(55, 56, 57, 58),
                 leaf(59, 60, 61)))),
      vec(15, 31, 47, 62)),
    62, 2, 2)
  let t2 = t.add(62)
  for (i: 0..62):
    check: t2.get(i)
           ~is i
  for (i: 0..3):
    check: t.root.get(i) === t2.root.get(i)
           ~is #true
  for (i: 0..3):
    check: t.root.get(3).get(i) === t2.root.get(3).get(i)
           ~is #true

  check: t2.size
         ~is t.size + 1
  check: t2.height
         ~is t.height
  check: t2.branch_factor
         ~is t.branch_factor


  let t = Tree()
  let t2:
    for values(tprime = t):
      each i: 0..(32 bits.(<<) 5) + 1
      tprime.add(i)
  check: t2.size
         ~is (32 bits.(<<) 5) + 1
  check: t2.height
         ~is 2

  check: Tree().set(0, 0)
         ~raises ""

  check: Tree(leaf(0, 1, 2), 3, 0, 2).set(0, -1)
         ~is Tree(leaf(-1, 1, 2), 3, 0, 2)

  let t = Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(2, 3))),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7))))),
           8,
           2,
           1)
  check: t.balanced
         ~is #true

  let t2 = t.set(2, -2)
  check: t2
         ~is Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(-2, 3))),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7))))),
           8,
           2,
           1)
  check: t.root.get(1) === t2.root.get(1)
         ~is #true
  check: t.root.get(0).get(0) === t2.root.get(0).get(0)
         ~is #true

  let t = Tree(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)),
               3, 1, 1)
  check: t.balanced
         ~is #false
  let t2 = t.set(1, -1)
  check: t2
         ~is Tree(Node(vec(leaf(0), leaf(-1, 2)), vec(1, 3)),
                  3, 1, 1)
  check: t.root.get(0) === t2.root.get(0)
         ~is #true
  check: t.root.sizes === t2.root.sizes
         ~is #true

  check: Tree().size
         ~is 0

  check: Tree().branch_factor
         ~is 5
         
  check: Tree(~bf: 2).width
         ~is 4

  check: Tree(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)), 4, 1, 1).get(1)
         ~is 1

  check: Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(2, 3))),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7))))),
           8,
           2,
           1).get(4)
         ~is 4

  check: Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(2, 3)),
                 vec(2, 4)),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7)),
                 vec(2, 4))),
             vec(4, 8)),
           8,
           2,
           1).get(4)
         ~is 4


module test:
  check: build(leaf(0, 1, 2), 1, 0, -1)
         ~is leaf(0, 1, 2, -1)
  check: build(Node(
                 vec(
                   Node(vec(leaf(0, 1), leaf(2, 3))),
                   Node(vec(leaf(4, 5))))),
               2, 2, 6)
         ~is Node(
           vec(
             Node(vec(leaf(0, 1), leaf(2, 3))),
             Node(vec(leaf(4, 5), leaf(6)))))

  check: new_branch(#'a, 0)
         ~is leaf(#'a)
  check: new_branch(#'a, 3)
         ~is Node(vec(Node(vec(Node(vec(leaf(#'a)))))))

  check: copyable_count(Node(vec(leaf(0, 1))), 2, 1)
         ~is 1
  check: copyable_count(Node(vec(leaf(0), leaf(1)), vec(1, 2)), 2, 1)
         ~is 2
  check: copyable_count(leaf(0), 100, 0)
         ~is 1

  check: copyable_count(Node(vec(Node(vec(leaf(0, 1), leaf(2, 3))), Node(vec(leaf(4, 5), leaf(6, 7))))),
                        2, 2)
         ~is 0

  check: copyable_count(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)),
                        2, 1)
         ~is 0

  def nd = Node(
    vec(
      Node(
        vec(
          leaf(0, 1),
          leaf(2)),
        vec(2, 3)),
      Node(
        vec(
          leaf(3, 4),
          leaf(5, 6)))),
    vec(3, 7))
  
  check: step(nd, 0, 1, 2)
         ~is values(0, 0)
  check: step(nd, 4, 1, 2)
         ~is values(1, 1)
  check: step(nd, 3, 1, 2)
         ~is values(1, 0)
  check: step(nd, 2, 1, 2)
         ~is values(0, 2)

  check: radix_of(4, 1, 0)
         ~is 0
  check: radix_of(0, 32, 1000000)
         ~is 0
  check: radix_of(4, 2, 1)
         ~is 1
  check: radix_of(2 ^ 5 ^ 4 - 1, 5, 3)
         ~is 31

  check: scan_sizes(vec(3, 7, 11), 4)
         ~is 1
  check: scan_sizes(vec(), 0)
         ~raises ""
  check: scan_sizes(vec(32, 63, 95), 64, radix_of(63, 5, 1))
         ~is 2
