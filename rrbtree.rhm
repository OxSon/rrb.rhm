#lang rhombus

import "utils.rkt" open
import "stv_compat.rhm" open

export:
  Tree

class Node(children :: Vec, sizes :: Vec || False = #false):
  constructor
  | (): super(vec())
  | (args, ...): super(args, ...)
 
  property balanced:
    !sizes
    
  method get(index):
    ref(children, index)

  method set(index, el) :~ Node:
    Node(set_vec(children, index, el), sizes)
    
fun leaf(args, ...) :~ Node:
  Node(vec(args, ...))
  
module test:
  check:
    Node(vec(1, 2, 3)).get(2)
    ~is 3

  let t1 = Node(vec(Node(vec(0, 1)), Node(vec(2, 3))), vec(2, 4))
  let t2 = t1.set(0, t1.get(0).set(0, -1))
  check: t2
         ~is Node(vec(Node(vec(-1, 1)), Node(vec(2, 3))), vec(2, 4))

  check: t1.sizes === t2.sizes
         ~is #true

  check: t1.get(1) === t2.get(1)
         ~is #true

  check: leaf(1, 2, 3)
         ~is Node(vec(1, 2, 3))


class Tree(root :: Node,
           size :: NonnegInt = 0,
           height :: NonnegInt = 0,
           branch_factor = bits.length(VEC_WIDTH) - 1,
           private max_width = 1 bits.(<<) branch_factor):
  
  constructor
  | (): super(Node())
  | (~bf: bf): super(Node(), 0, 0, bf)
  | (args, ...): super(args, ...)

  property balanced:
    root.balanced
    
  property width:
    max_width

  // get the element at `index`
  method get(index :: Int):
    fun _get(node, index, depth):
      if node.balanced
      | for values(n = node):
          each i: 0 .. depth + 1
          n.get(radix_of(index, branch_factor, depth - i))
      | def (branch_index, subindex) = step(node, index, branch_factor, depth)
        _get(node.get(branch_index), subindex, depth - 1)

    _get(root, index, height)

  // set the slot at `index` to `el`
  method set(index :: Int, el) :~ Tree:
    fun _set(node, index, el, depth):
      cond
      | depth == 0:
          node.set(radix_of(index, branch_factor, depth), el)
      | node.balanced:
          def branch_index = radix_of(index, branch_factor, depth)
          node.set(branch_index, _set(node.get(branch_index), index, el, depth - 1))
      | ~else:
          def (branch_index, subindex) = step(node, index, branch_factor, depth)
          node.set(branch_index, _set(node.get(branch_index), subindex, el, depth - 1))

    Tree(_set(root, index, el, height), size, height, branch_factor)


  // add `el` to end of vector
  method add(el) :~ Tree:
    def count = copyable_count(root, width, height)
    if count == 0
    | /* not enough space in original tree */
      Tree(Node(vec(root, new_branch(el, height)),
                root.sizes && vec(size, size + 1)),
           size + 1,
           height + 1,
           branch_factor)
    | /* enough space in original tree */
      Tree(build(root, count, height, el),
           size + 1,
           height,
           branch_factor)
          
                
  
  method concat(rhs :: Tree) :~ Tree:
    TODO "concat"
  
  method split(at :: NonnegInt, side :: Any.of(#'left, #'right, #'l, #'r)) :~ Tree:
    TODO "split"

module test:
  check: Tree(leaf(), 0, 0).add(0)
         ~is Tree(leaf(0), 1, 0)
  check: Tree(leaf(0), 1, 0, 1).add(1)
         ~is Tree(leaf(0, 1), 2, 0, 1)
  check: Tree(leaf(0, 1), 2, 0, 1).add(2)
         ~is Tree(Node(vec(leaf(0, 1), leaf(2))), 3, 1, 1)
  check: Tree(Node(vec(leaf(0), leaf(1)), vec(1, 2)), 2, 1, 1).add(2)
         ~is Tree(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)), 3, 1, 1)

  check: (Tree(
           Node(
             vec(Node(vec(leaf(0, 1), leaf(2))),
                 Node(vec(leaf(3, 4), leaf(5, 6)))),
             vec(3, 7)
           ),
           7, 2, 1)
          ).add(7)
         ~is Tree(
           Node(vec(
                  Node(
                    vec(Node(vec(leaf(0, 1), leaf(2))),
                        Node(vec(leaf(3, 4), leaf(5, 6)))),
                    vec(3, 7)
                  ),
                  Node(
                    vec(Node(vec(leaf(7)))))),
                vec(7, 8)),
           8, 3, 1)

  let t = Tree(
    Node(
      vec(
        Node(vec(leaf(0,   1,  2,  3),
                 leaf(4,   5,  6,  7),
                 leaf(8,   9, 10, 11),
                 leaf(12, 13, 14))),
        Node(vec(leaf(15, 16, 17, 18),
                 leaf(19, 20, 21, 22),
                 leaf(23, 24, 25, 26),
                 leaf(27, 28, 29, 30))),
        Node(vec(leaf(31, 32, 33, 34),
                 leaf(35, 36, 37, 38),
                 leaf(39, 40, 41, 42),
                 leaf(43, 44, 45, 46))),
        Node(vec(leaf(47, 48, 49, 50),
                 leaf(51, 52, 53, 54),
                 leaf(55, 56, 57, 58),
                 leaf(59, 60, 61)))),
      vec(15, 31, 47, 62)),
    62, 2, 2)
  let t2 = t.add(62)
  for (i: 0..62):
    check: t2.get(i)
           ~is i
  for (i: 0..3):
    check: t.root.get(i) === t2.root.get(i)
           ~is #true
  for (i: 0..3):
    check: t.root.get(3).get(i) === t2.root.get(3).get(i)
           ~is #true

  check: t2.size
         ~is t.size + 1
  check: t2.height
         ~is t.height
  check: t2.branch_factor
         ~is t.branch_factor


  let t = Tree()
  let t2:
    for values(tprime = t):
      each i: 0..(32 bits.(<<) 5) + 1
      tprime.add(i)
  check: t2.size
         ~is (32 bits.(<<) 5) + 1
  check: t2.height
         ~is 2

  check: Tree().set(0, 0)
         ~raises ""

  check: Tree(leaf(0, 1, 2), 3, 0, 2).set(0, -1)
         ~is Tree(leaf(-1, 1, 2), 3, 0, 2)

  let t = Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(2, 3))),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7))))),
           8,
           2,
           1)
  check: t.balanced
         ~is #true

  let t2 = t.set(2, -2)
  check: t2
         ~is Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(-2, 3))),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7))))),
           8,
           2,
           1)
  check: t.root.get(1) === t2.root.get(1)
         ~is #true
  check: t.root.get(0).get(0) === t2.root.get(0).get(0)
         ~is #true

  let t = Tree(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)),
               3, 1, 1)
  check: t.balanced
         ~is #false
  let t2 = t.set(1, -1)
  check: t2
         ~is Tree(Node(vec(leaf(0), leaf(-1, 2)), vec(1, 3)),
                  3, 1, 1)
  check: t.root.get(0) === t2.root.get(0)
         ~is #true
  check: t.root.sizes === t2.root.sizes
         ~is #true

  check: Tree().size
         ~is 0

  check: Tree().branch_factor
         ~is 5
         
  check: Tree(~bf: 2).width
         ~is 4

  check: Tree(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)), 4, 1, 1).get(1)
         ~is 1

  check: Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(2, 3))),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7))))),
           8,
           2,
           1).get(4)
         ~is 4

  check: Tree(
           Node(
             vec(
               Node(
                 vec(
                   leaf(0, 1),
                   leaf(2, 3)),
                 vec(2, 4)),
               Node(
                 vec(
                   leaf(4, 5),
                   leaf(6, 7)),
                 vec(2, 4))),
             vec(4, 8)),
           8,
           2,
           1).get(4)
         ~is 4


fun radix_of(index :: Int, branch_factor, height) :~ Int:
  if height == 0
  | index bits.and ((1 bits.(<<) branch_factor) - 1)
  | (index bits.(>>) (branch_factor * height)) bits.and ((1 bits.(<<) branch_factor) - 1)
                      
fun scan_sizes(sizes, target_index, i = 0) :~ Int:
  if ref(sizes, i) <= target_index
  | scan_sizes(sizes, target_index, i + 1)
  | i

// calculate next branch to take and subindex of `index` along that path
fun step(node :: Node, index, branch_factor, depth) :~ (NonnegInt, NonnegInt):
  def branch = scan_sizes(node.sizes, index, radix_of(index, branch_factor, depth))
  values(branch,
         if branch == 0
         | index
         | index - ref(node.sizes, branch - 1))

// return (# of copyable nodes, index in last copyable node which can be inserted-into)
// where a copyable node is one that has room for another element (or branch)
fun copyable_count(node, width, height):
  def (_, count):
    for values(n = node, count = 0):
      each i: 0 .. height + 1
      def l = len(n.children)
      values(if l == 0
             | n
             | n.get(l - 1),
             if l < width
             | i + 1
             | count)
  count

fun new_branch(el, height):
  if height == 0
  | leaf(el)
  | Node(vec(new_branch(el, height - 1)))


fun build(n, count, height, el):
  if count < 2
  | if height == 0
    | Node(add_vec(n.children, el))
    | Node(add_vec(n.children,
                   new_branch(el, height - 1)))
  | Node(set_vec(n.children,
                 len(n.children) - 1,
                 build(n.get(len(n.children) - 1),
                       count - 1,
                       height - 1,
                       el)),
         n.sizes && set_vec(n.sizes,
                            len(n.sizes) - 1,
                            ref(n.sizes, len(n.sizes) - 1) + 1))

module test:
  check: build(leaf(0, 1, 2), 1, 0, -1)
         ~is leaf(0, 1, 2, -1)
  check: build(Node(
                 vec(
                   Node(vec(leaf(0, 1), leaf(2, 3))),
                   Node(vec(leaf(4, 5))))),
               2, 2, 6)
         ~is Node(
           vec(
             Node(vec(leaf(0, 1), leaf(2, 3))),
             Node(vec(leaf(4, 5), leaf(6)))))

  check: new_branch(#'a, 0)
         ~is leaf(#'a)
  check: new_branch(#'a, 3)
         ~is Node(vec(Node(vec(Node(vec(leaf(#'a)))))))

  check: copyable_count(Node(vec(leaf(0, 1))), 2, 1)
         ~is 1
  check: copyable_count(Node(vec(leaf(0), leaf(1)), vec(1, 2)), 2, 1)
         ~is 2
  check: copyable_count(leaf(0), 100, 0)
         ~is 1

  check: copyable_count(Node(vec(Node(vec(leaf(0, 1), leaf(2, 3))), Node(vec(leaf(4, 5), leaf(6, 7))))),
                        2, 2)
         ~is 0

  check: copyable_count(Node(vec(leaf(0), leaf(1, 2)), vec(1, 3)),
                        2, 1)
         ~is 0

  def nd = Node(
    vec(
      Node(
        vec(
          leaf(0, 1),
          leaf(2)),
        vec(2, 3)),
      Node(
        vec(
          leaf(3, 4),
          leaf(5, 6)))),
    vec(3, 7))
  
  check: step(nd, 0, 1, 2)
         ~is values(0, 0)
  check: step(nd, 4, 1, 2)
         ~is values(1, 1)
  check: step(nd, 3, 1, 2)
         ~is values(1, 0)
  check: step(nd, 2, 1, 2)
         ~is values(0, 2)

  check: radix_of(4, 1, 0)
         ~is 0
  check: radix_of(0, 32, 1000000)
         ~is 0
  check: radix_of(4, 2, 1)
         ~is 1
  check: radix_of(2 ^ 5 ^ 4 - 1, 5, 3)
         ~is 31

  check: scan_sizes(vec(3, 7, 11), 4)
         ~is 1
  check: scan_sizes(vec(), 0)
         ~raises ""
  check: scan_sizes(vec(32, 63, 95), 64, radix_of(63, 5, 1))
         ~is 2
