#lang rhombus/static

export:
  //Vec
  vec
  unsafe
  add_vec
  set_vec
  vec_take
  append_vec
  array_append
  vec_drop
  vec_drop_right
  vec_split
  if_not
  

/* Array utilities for imitating COW immutable indexed sequences */
// TODO could 'Immutable' be an annotation?
import rhombus/meta open

import lib("racket/base.rkt") as r:
  rename #{vector-immutable} as vec
  //expose vec
  
import lib("racket/vector.rkt") as vector:
  rename:
    #{vector-drop} as vec_drop
    #{vector-drop-right} as vec_drop_right
    #{vector-split-at} as vec_split
    #{vector-take} as vec_take
    #{vector-append} as array_append // we use this for our mutable arrays only, or internally in this module

  #//
  expose:
    vec_drop
    vec_drop_right
    vec_split
    vec_take
    array_append

  
namespace unsafe: 
  import lib("racket/unsafe/ops.rkt") as unsafe:
    rename:
      #{unsafe-vector*->immutable-vector!} as freeze_vec

    #//
    expose:
      freeze_vec

  fun freeze_vec(v :~ Array) :~ Array:
    unsafe.freeze_vec(v)
      
  export freeze_vec
  
#//  
annot.macro 'Vec':
  annot_meta.pack_predicate('r.#{vector?} && r.#{immutable?}')

fun vec(e0, ...) :~ Array:
  macro 'do($e0, ...)':
    'r.vector($e0, ...)'
  do(e0, ...)
fun vec_drop(v :~ Array, pos :~ Int) :~ Array:
  vector.vec_drop(v, pos)
fun vec_drop_right(v :~ Array, pos :~ Int) :~ Array:
  vector.vec_drop_right(v, pos)
fun vec_split(v :~ Array, pos :~ Int) :~ Array:
  vector.vec_split(v, pos)
fun vec_take(v :~ Array, pos :~ Int) :~ Array:
  vector.vec_take(v, pos)
fun array_append(v0 :~ Array, ...) :~ Array:
  macro 'do($v0, ...)':
    'vector.array_append($v0, ...)'
  do(v0, ...)

fun add_vec(v :~ Array, el) :~ Array:
  def ret = Array.make(v.length() + 1)
  Array.copy_from(ret, 0, v)
  ret[v.length()] := el
  unsafe.freeze_vec(ret)


fun set_vec(v :~ Array, idx :~ NonnegInt, el) :~ Array:
  def ret = Array.copy(v)
  ret[idx] := el
  unsafe.freeze_vec(ret)  


fun append_vec(vec0, ...) :~ Array:
  unsafe.freeze_vec(array_append(vec0, ...))

macro 'TODO $(msg :: String)':
  'error("TODO: " +& $msg)'

macro 'if_not $condition ...:
         $do':
  'if !($condition ...)
   | $do
   | #void'
  
module test:

  check: set_vec(vec(1, 2, 3), 1, -1)
         ~is_now vec(1, -1, 3)

// this no longer holds true
  #//
  check: vec(1, 2, 3)[0] := -1
         ~raises ""

  check: unsafe.freeze_vec(Array(1, 2, 3))
         ~is_now vec(1, 2, 3)

  check: add_vec(vec(1, 2, 3), 4)
         ~is_now vec(1, 2, 3, 4)

  check: append_vec(vec(1, 2, 3), vec(4, 5))
         ~is_now vec(1, 2, 3, 4, 5)

  check: append_vec(vec(#'a, #'b, #'c),
                    vec(1, 2, 3),
                    vec("the industrial revolution and its consequences..."))
         ~is_now vec(#'a, #'b, #'c,
                     1, 2, 3,
                     "the industrial revolution and its consequences...")

  check: TODO "foo"
         ~raises "foo"
         
  fun inv(x :~ Int) :~ maybe(Int):
    if_not x == 0:
      1 / x
    
  check: inv(2)
         ~is 1/2 
    
  check: inv(0)
         ~is #void